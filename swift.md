# Swift

## Ecosystem
- ライブラリ
  - 標準ライブラリ
  - コアライブラリ
    - Foundation
    - libdispatch
    - XCTest
    - ..
- 開発ツール
  - Swift Package Manager
  - LLDB

## Project Structure
- `swift package init --type executable`
```
<your-project-name>
 ├── Package.swift                          ... Manifest File
 ├── README.md
 ├── Sources
 │    └── <your-project-name>
 │           └── main.swift
 └── Tests
       ├── LinuxMain.swift
       └── <your-project-name>Tests
              ├── XCTestManifests.swift
              └── demoTests.swift
```
- `swift build`

## 変数
- variables: `var totalValue:Int`
- constants: `let threshould:Int`

## 型
- struct, class, enum:
    - common rule:
        - property/method:
            - self: instance property/method にアクセス
            - Self: static property/method にアクセス
        - property:
            - property observer:
                - `var プロパティ名 = 初期値 {`
                - `    willSet {`
                - `        プロパティの変更前に実行する文`
                - `        変更後の値には定数newValueとしてアクセスできる`
                - `    }`
                - `    didSet {`
                - `        プロパティの変更後に実行する文`
                - `    }`
                - `}`
            - lazy stored property:
                - `static lazy var スタティックプロパティ名: プロパティの型 = 式`
            - computed property:
                - `var fahrenheit: Double {`
                - `    get {`
                - `        return (9.0 / 5.0) * celsius + 32.0`
                - `    }`
                - `    set {`
                - `        celsius = (5.0 / 9.0) * (newValue - 32.0)`
                - `    }`
                - `}`
        - method:
            - initializer: `init(..) { }`
            - failable initializer: `init?(..) { }`
            - subscription:
                - `struct Matrix {`
                - `    var rows: [[Int]]`
                - `    subscript(row: Int, column: Int) -> Int {`
                - `        get {`
                - `            return rows[row][column]`
                - `        }`
                - `        set {`
                - `            rows[row][column] = newValue`
                - `        }`
                - `    }`
                - `}`
                - `let matrix = Matrix(rows: [`
                - `    [1, 2, 3],`
                - `    [4, 5, 6],`
                - `    [7, 8, 9],`
                - `])`
                - `let element = matrix[1, 1] // 5`
        - extension:
    - 値型 (struct, enum):
        - struct:
            - mutating:
                - `extension Int {`
                - `    mutating func increment() {`
                - `        self += 1`
                - `    }`
                - `}`
                - `var a = 1 // 1`
                - `a.increment() // 2（aに再代入が行われている）`
                - `let b = 1`
                - `b.increment() // bに再代入できないためコンパイルエラー`
                - struct の stored property の変更は再代入を必要とするため、stored property の変更を含む method には mutating キーワードが必要
            - memberwise initializer:
                - init を定義しなくても良い
        - enum:
            - stored property は持てない (computed property のみ)
    - 参照型 (class):
        - class: 👍`参照型で継承が可能`
            - override:
            - final: override 禁止, class 自体にも付与できる
            - class property/class method: static に似ているが、子クラスで override できる
- protocol:
    - `protocol SomeProtocol {`
    - `    var title: String { get set }`
    - `}`
    - protocol composition:
        - `func someFunction(x: SomeProtocol1 & SomeProtocol2) {`
        - `    x.variable1 + x.variable2`
        - `}`
    - associatedtype:
    - クラス専用 protocol: `protocol SomeClassOnlyProtocol: class {}`
    - 代表的なの:
        - Sequence
            - `forEach()`, `filter()`, `map()`, `flatMap()`, `compactMap()`, `reduce()`
        - Collection
            - `count()`, `first()`, `last()`
- Generics:
- 汎用:
    - Optional
    - コレクション
        - 配列
            - Array<Element>
            - 👍\[Element]
        - 辞書
            - Dictionary<Key, Value>
            - 👍\[Key, Value]
        - 範囲
            - Range<Bound>, CountableRange<Bound>, ClosedRange<Bound>, CountableClosedRange<Bound>
                - `let range = 1..<4 // CountableRange(1..<4)`
                - `let range = 1...4 // CountableClosedRange(1...4)`
                - `for value in range {`
                - `    print(value)`
                - `}`
        - 文字(列)
            - Character
            - String
- 操作
    - initializer: `let a:Int = 123          let b:Int64 = Int64(a)`
    - optional:
        - 明示的アンラップ
            - `let optionlInt: Int? = 1`
                - 👍デフォルト (??):
                    - `let optionalInt: Int? = nil`
                    - `let int = optionalInt ?? 3 // 3`
                - 強制アンラップ (!):
                    - `let a: Int? = 1`
                    - `let b: Int? = 1`
                    - `a! + b! // 2`
                - 👍オプショナルバインディング:
                    - `let optionalDouble = Optional(1.0) // 1`
                    - `let optionalIsInfinite: Bool?`
                    - `if let double = optionalDouble {`
                    - `    optionalIsInfinite = double.isInfinite`
                    - `} else {`
                    - `    optionalIsInfinite = nil`
                    - `}`
                - 👍オプショナルチェイン (?):
                    - `let optionalDouble = Optional(1.0) // Optional(1.0)`
                    - `let optionalIsInfinite = optionalDouble?.isInfinite`
                    - `print(String(describing: optionalIsInfinite))`
        - 暗黙的アンラップ
            - `let a: Int! = 1`
            - `a + 1 // Int型と同様に演算が可能`
            - `var b: Int! = nil`
            - `b + 1 // 値が入っていないため実行時エラー`
    - Cast:
        - アップキャスト:
            - 👍明示的アップキャスト:
                - `let any = "abc" as Any`
            - 暗黙的アップキャスト:
                - `let any: Any = "abc"`
        - ダウンキャスト:
            - 👍通常のダウンキャスト (?):
                - `let any = 1 as Any`
                - `let int = any as? Int // Optional(1)`
                - `let string = any as? String // nil`
            - 強制的ダウンキャスト (!):
                - `let any = 1 as Any`
                - `let int = any as! Int`
                - `let string = any as! String // 実行時エラー`

## 関数
- @
    - `@discardableResult`
- func:
    - 引数:
        - 可変長引数: `func print(strings: String...) {`
        - inout: `func greet(user: inout String) {`
- closure
    - フォーマット:
        - `{ (引数名1: 型, 引数名2: 型...) -> 戻り値の型 in`
        - `    クロージャの実行時に実行される文`
        - `    必要に応じてreturn文で戻り値を返却する`
        - `}`
    - キャプチャ:
        - `let counter: () -> Int`
        - `do {`
        - `    var count = 0`
        - `    counter = {`
        - `        count += 1`
        - `        return count`
        - `    }`
        - `}`
        - `counter() // 1`
        - `counter() // 2`
    - @escaping
        - `var queue = [() -> Void]()`
        - `func enqueue(operation: @escaping () -> Void) {`
        - `    queue.append(operation)`
        - `}`
        - `enqueue { print("executed") }`
        - `enqueue { print("executed") }`
        - `queue.forEach { $0() }`
    - @autoclosure
        - `func or(_ lhs: Bool, _ rhs: @autoclosure () -> Bool) -> Boo`
            - 正格評価
                - Swiftでは多くのプログラミング言語と同じく、関数の引数がその関数に引き渡されるより前に実行される
                    - クロージャを引数に渡すことで、遅延評価が可能
                    - @autoclosure を使えば、呼び出し側も簡潔になる
    - 👍トレイリングクロージャ
        - `func execute(parameter: Int, handler: (String) -> Void) {`
        - `    handler("parameter is \(parameter)")`
        - `}`
        - `execute(parameter: 2) { string in`
        - `    print(string)`
        - `}`

## 制御文
- guard
    - `guard 条件式 else {`
    - `    条件式がfalseの場合に実行される文`
    - `    guard文が記述されているスコープの外に退出する必要がある`
    - `}`
    - `guard let int = a as? Int else {`
    - `    print("aはInt型ではありません")`
    - `    return`
    - `}`
    - `// intはguard文以降でも使用可能`
    - `print("値はInt型の\(int)です")`
- switch
    - `ラベル名: switch 制御式 {`
    - `case パターン where 条件式:`
    - `    制御式がパターンにマッチし、かつ、条件式を満たす場合に実行される文`
    - `    break ラベル名`
    - `    fallthrough`
    - `default:`
    - `    制御式がいずれのパターンにもマッチしなかった場合に実行される文`
    - `}`
        - for も for の前にラベル名をつけて、break 時に指定できる
- defer
- いろんなパターンマッチ
    - if
        - `let value = 9`
        - `if case 1...10 = value {`
        - `    print("1以上10以下の値です")`
        - `}`
    - guard
        - `let value = 9`
        - `guard case 1...10 = value else {`
        - `    return`
        - `}`
    - for
        - `let array = [1, 2, 3, 4]`
        - `for case 2...3 in array {`
        - `    print("2以上3以下の値です")`
        - `}`
    - while
        - `var nextValue = Optional(1)`
        - `while case let value? = nextValue {`
        - `    print("value: \(value)")`
        - `    if value >= 3 {`
        - `        nextValue = nil`
        - `    } else {`
        - `        nextValue = value + 1`
        - `    }`
        - `}`

## 応用
- イベント通知
    - Delegate Pattern
    - Closure
    - Observer Pattern
        - Notification / NotificationCenter
            - `import Foundation`
            - `class Poster {`
            - `    static let notificationName = Notification.Name("SomeNotification")`
            - `    func post() {`
            - `        NotificationCenter.default.post(name: Poster.notificationName, object: nil)`
            - `    }`
            - `}`
            - `class Observer {`
            - `    init() {`
            - `        NotificationCenter.default.addObserver(`
            - `            self,`
            - `            selector: #selector(handleNotification(_:)),` Objective-C のセレクタ
            - `            name: Poster.notificationName,`
            - `            object: nil)`
            - `    }`
            - `    deinit {`
            - `        NotificationCenter.default.removeObserver(self)`
            - `    }`
            - `    @objc func handleNotification(_ notification: Notification) {`
            - `        print("通知を受け取りました")`
            - `    }`
            - `}`
- 非同期処理
    - GCD (Closure を使用)
        - Type
            - Serial Dispatch Queue
            - Concurrent Dispatch Queue
            - `import Dispatch`
            - `\\ Main Queue` (Serial Dispatch Queue 唯一ひとつ)
            - `let queue = DispatchQueue.main // メインディスパッチキューを取得`
            - `\\ Global Queue` (Concurrent Dispatch Queue 複数ある)
            - `let queue = DispatchQueue.global(qos: .userInitiated)`
            - `\\ Original Queue` (Serial, Concurrent 好きな方を選べる)
            - `let queue = DispatchQueue(`
            - `    label: "com.my_company.my_app.upload_queue",`
            - `    qos: .default,`
            - `    attributes: [.concurrent])`
            - `queue.async {`
            - `    Thread.isMainThread // false`
            - `    print("非同期の処理")`
            - `}`
    - Operation, OperationQueue (Class を使用)
        - `import Foundation`
        - `class SomeOperation : Operation {`
        - `    let number: Int`
        - `    init(number: Int) { self.number = number }`
        - `    override func main() {`
        - `        Thread.sleep(forTimeInterval: 1)`
        - `        guard !isCancelled else { return }`
        - `        print(number)`
        - `    }`
        - `}`
        - `let queue = OperationQueue()`
        - `queue.name = "com.example.my_operation_queue"`
        - `queue.maxConcurrentOperationCount = 2`
        - `queue.qualityOfService = .userInitiated`
        - `var operations = [SomeOperation]()`
        - `for i in 0..<10 {`
        - `    operations.append(SomeOperation(number: i))`
        - `    if i > 0 {`
        - `        operations[i].addDependency(operations[i-1])`
        - `    }`
        - `}`
        - `queue.addOperations(operations, waitUntilFinished: false)`
        - `operations[6].cancel()`
    - Thread
- Error Handling
    - Optional 型の利用
    - Result 型の利用
